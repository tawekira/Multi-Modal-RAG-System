# -*- coding: utf-8 -*-
"""RAG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fy1l-NlYXCglH27hZXU9ClVEATh-HfTi
"""

import os
from google.colab import userdata

!apt-get install -y poppler-utils
!sudo apt install tesseract-ocr
!pip install pytesseract
!apt-get install libmagic-dev
!pip install python-magic

# Commented out IPython magic to ensure Python compatibility.
# %pip install "unstructured[all-docs]"
!pip install Pillow
!pip install lxml

!pip install pymongo

"""Partition PDF text and images"""

from google.colab import drive
drive.mount('/content/drive')
filepath = "/content/drive/MyDrive/DataAnalysis.pdf"

from unstructured.partition.pdf import partition_pdf
chunks = partition_pdf(
    filename = filepath,

    infer_table_structure=True,
    stategy="hi_res",

    extract_image_block_types=["Image"],
    extract_image_block_to_payload = True,

    chunking_strategy="by_title",
    max_characters=10000,
    combine_text_under_n_chars = 2000,
    new_after_n_chars = 6000,


)

"""Separate extracted elements into text and images"""

texts = chunks
print(len(texts))

def get_images_base64(chunks):
  images_b64 = []
  for chunk in chunks:
    chunk_els = chunk.metadata.orig_elements
    for el in chunk_els:
      if "Image" in str(type(el)):
        images_b64.append(el.metadata.image_base64)
  return images_b64

images = get_images_base64(chunks)
print(len(images))

"""Check images"""

import base64
from IPython.display import Image, display

def display_base64_image(base64_code):
  image_data = base64.b64decode(base64_code)
  display(Image(data=image_data))

display_base64_image(images[1])

"""Summarise images"""

import google.generativeai as genai
import time

GOOGLE_API_KEY = userdata.get('GOOGLE_API_KEY')
genai.configure(api_key=GOOGLE_API_KEY)

if GOOGLE_API_KEY:
    try:
        gemini_model = genai.GenerativeModel('gemini-flash-latest')
    except Exception as e:
        print(f"Error initializing Gemini model: {e}")
        gemini_model = None
else:
    gemini_model = None

if gemini_model and images:
    image_summaries = []
    prompt_template_gemini = """Describe the image in detail. For context,
                      the image is part of a physics textbook discussing
                      the measurement of physical quantities."""

    print("Starting Gemini image summarization...")
    for i, image_data in enumerate(images):
        try:
            response = gemini_model.generate_content([prompt_template_gemini, {"mime_type": "image/jpeg", "data": image_data}])
            summary = response.text
            image_summaries.append(summary)
            print(f"Successfully summarized image {i+1}/{len(images)}.")
            time.sleep(1)
        except Exception as e:
            print(f"Error summarizing image {i+1}/{len(images)}: {e}")
            image_summaries.append(f"Error summarizing image: {e}")

    print(f"\nGenerated summaries for {len(image_summaries)} images using Gemini.")
else:
    print("Gemini model not initialized or no images found to summarize.")

print(image_summaries[0])

"""Embedding"""

from google import genai
from google.colab import userdata

GOOGLE_API_KEY = userdata.get('GOOGLE_API_KEY')

client = genai.Client(api_key=GOOGLE_API_KEY)

def embed(content):
  result = client.models.embed_content(
      model="gemini-embedding-001",
      contents = content
  )
  return result.embeddings

import pymongo
text_embeddings = []
for text_element in texts:
  text_content = text_element.text
  embedding_object_list = embed(text_content)
  embedding_object = embedding_object_list[0]
  text_embeddings.append(embedding_object)

text_docs = []
for i, (embedding_object, text_element) in enumerate(zip(text_embeddings, texts)):
  doc = {
      "type": "text",
      "text": text_element.text,
      "embedding": embedding_object.values,
  }
  text_docs.append(doc)

print(text_docs[0])

mongo_client = pymongo.MongoClient(userdata.get('MONGO_URI'))
db = mongo_client["RAG"]
db["data"].insert_many(text_docs)

image_embeddings = []
for summary in image_summaries:
  text_content = summary
  embedding_object_list = embed(text_content)
  embedding_object = embedding_object_list[0]
  image_embeddings.append(embedding_object)

image_docs = []
for i, (embedding_object, summary, b64) in enumerate(zip(image_embeddings, image_summaries, images)):
  doc = {
      "type": "image",
      "image": b64,
      "text": summary,
      "embedding": embedding_object.values,
  }
  image_docs.append(doc)

print(image_docs[0])

mongo_client = pymongo.MongoClient(userdata.get('MONGO_URI'))
db = mongo_client["RAG"]
db["data"].insert_many(image_docs)

"""Querying"""

query = "Tell me more about systematic errors"
embedding_object = embed(query)[0]

results = db.data.aggregate([
  {
    "$vectorSearch": {
      "index": "vectorsearch",
      "path": "embedding",
      "queryVector": embedding_object.values,
      "numCandidates": 50,
      "limit": 2
    }
  },
  {

    "$addFields": {
      "score": { "$meta": "vectorSearchScore" }
    }
  },
  {

    "$match": {
      "score": { "$gte": 0.7 }
    }
  },

])
retrieved_texts = []
retrieved_images = []
retrieved_ids = []
for document in results:
  retrieved_texts.append(document["text"])
  retrieved_ids.append(str(document["_id"]))
  if document["type"] == "image":
    retrieved_images.append(document["image"])
print(len(retrieved_texts))
print(len(retrieved_images))

"""Answering"""

text_delimiter = "\n\n--- DOCUMENT ENDS ---\n\n"
context_string = text_delimiter.join(retrieved_texts)

if gemini_model:
    prompt_template_gemini = f"""
    You are an accurate technical assistant. Answer the question only based on
    the context provided below. If the answer is not in the context, only state
    that the information is unavailable, nothing more.

    --- START CONTEXT ---
    {context_string}
    --- END CONTEXT ---

    Question: {query}
    """

    response = gemini_model.generate_content([prompt_template_gemini])
    for image in retrieved_images:
      display_base64_image(image)
    print("\n")
    print(response.text)
    print("\n")
    print("Document ids:")
    print(",".join(retrieved_ids))
